<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAV Silence Inserter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .custom-file-input::-webkit-file-upload-button {
            visibility: hidden;
        }
        .custom-file-input::before {
            content: 'Select WAV File';
            display: inline-block;
            background: #4A5568; 
            border: 1px solid #718096;
            border-radius: 0.375rem; 
            padding: 0.5rem 1rem;
            outline: none;
            white-space: nowrap;
            -webkit-user-select: none;
            cursor: pointer;
            font-weight: 500;
            color: white;
        }
        .custom-file-input:hover::before {
            background: #2D3748;
        }
        .custom-file-input:active::before {
            background: #1A202C; 
        }
        #drop-zone {
            border: 2px dashed #4A5568;
            transition: all 0.2s ease-in-out;
        }
        #drop-zone.drag-over {
            border-color: #38B2AC; 
            background-color: rgba(56, 178, 172, 0.1);
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 space-y-6">
        <div class="text-center">
            <h1 class="text-3xl font-bold text-white">WAV Silence Inserter</h1>
            <p class="text-gray-400 mt-2">Add precise silence to the start of your WAV files, completely in your browser.</p>
        </div>

        <div id="drop-zone" class="rounded-lg p-8 text-center cursor-pointer">
            <input type="file" id="fileInput" accept=".wav" class="hidden">
            <label for="fileInput" class="cursor-pointer">
                <svg class="mx-auto h-12 w-12 text-gray-500" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true">
                    <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
                <p class="mt-4 text-lg font-medium text-gray-300">
                    <span class="text-teal-400">Upload a file</span> or drag and drop
                </p>
                <p class="mt-1 text-sm text-gray-500">WAV files up to 200MB</p>
                <p id="fileName" class="mt-4 text-sm font-semibold text-teal-300"></p>
            </label>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="bg-gray-700 p-4 rounded-lg">
                <h3 class="font-semibold text-white mb-3">Add Silence by Beats</h3>
                <div class="flex items-center space-x-3">
                    <input type="number" id="beats" placeholder="Beats" value="1" class="w-full bg-gray-800 border border-gray-600 rounded-md px-3 py-2 focus:ring-2 focus:ring-teal-500 focus:border-teal-500">
                    <span class="text-gray-400">@</span>
                    <input type="number" id="bpm" placeholder="BPM" value="120" class="w-full bg-gray-800 border border-gray-600 rounded-md px-3 py-2 focus:ring-2 focus:ring-teal-500 focus:border-teal-500">
                </div>
                 <div class="mt-2 text-center">
                    <input type="radio" id="unitBeats" name="silenceUnit" value="beats" checked class="form-radio h-4 w-4 text-teal-600 bg-gray-700 border-gray-600 focus:ring-teal-500">
                    <label for="unitBeats" class="ml-2 text-sm text-gray-300">Use this method</label>
                </div>
            </div>
            <!-- By Milliseconds -->
            <div class="bg-gray-700 p-4 rounded-lg">
                <h3 class="font-semibold text-white mb-3">Add Silence by Time</h3>
                <input type="number" id="milliseconds" placeholder="Milliseconds" class="w-full bg-gray-800 border border-gray-600 rounded-md px-3 py-2 focus:ring-2 focus:ring-teal-500 focus:border-teal-500">
                 <div class="mt-2 text-center">
                    <input type="radio" id="unitMs" name="silenceUnit" value="ms" class="form-radio h-4 w-4 text-teal-600 bg-gray-700 border-gray-600 focus:ring-teal-500">
                    <label for="unitMs" class="ml-2 text-sm text-gray-300">Use this method</label>
                </div>
            </div>
        </div>
        
        <button id="processBtn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 disabled:bg-gray-600 disabled:cursor-not-allowed">
            Process File
        </button>

        <div id="status" class="bg-gray-900 p-4 rounded-lg min-h-[100px] text-center flex items-center justify-center">
            <p class="text-gray-500">Waiting for file...</p>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('drop-zone');
        const fileNameDisplay = document.getElementById('fileName');
        const beatsInput = document.getElementById('beats');
        const bpmInput = document.getElementById('bpm');
        const millisecondsInput = document.getElementById('milliseconds');
        const unitBeatsRadio = document.getElementById('unitBeats');
        const unitMsRadio = document.getElementById('unitMs');
        const processBtn = document.getElementById('processBtn');
        const statusDiv = document.getElementById('status');
        
        let selectedFile = null;

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'audio/wav') {
                fileInput.files = files;
                handleFileSelect({ target: { files: files } });
            } else {
                updateStatus('error', 'Please drop a valid .wav file.');
            }
        });

        fileInput.addEventListener('change', handleFileSelect);

        function handleFileSelect(event) {
            if (event.target.files.length > 0) {
                selectedFile = event.target.files[0];
                if (selectedFile.size > 200 * 1024 * 1024) {
                    updateStatus('error', 'File is too large (max 200MB).');
                    selectedFile = null;
                    fileNameDisplay.textContent = '';
                    return;
                }
                fileNameDisplay.textContent = selectedFile.name;
                updateStatus('info', 'File ready. Configure silence and click Process.');
            }
        }

        processBtn.addEventListener('click', async () => {
            if (!selectedFile) {
                updateStatus('error', 'Please select a WAV file first.');
                return;
            }

            processBtn.disabled = true;
            updateStatus('info', 'Processing... This may take a moment for large files.');

            try {
                const arrayBuffer = await selectedFile.arrayBuffer();
                const processedBlob = await processWav(arrayBuffer);
                
                const url = URL.createObjectURL(processedBlob);
                const originalName = selectedFile.name.replace(/\.wav$/i, '');
                
                let offsetString = '';
                if(unitBeatsRadio.checked) {
                    const beats = parseFloat(beatsInput.value) || 0;
                    offsetString = `+${beats}beats`;
                } else {
                    const ms = parseFloat(millisecondsInput.value) || 0;
                    offsetString = `+${ms}ms`;
                }

                const newFileName = `${originalName}_offset${offsetString}.wav`;

                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = newFileName;
                downloadLink.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200';
                downloadLink.textContent = `Download ${newFileName}`;
                
                statusDiv.innerHTML = '';
                statusDiv.appendChild(downloadLink);

            } catch (error) {
                console.error('Processing Error:', error);
                updateStatus('error', `An error occurred: ${error.message}`);
            } finally {
                processBtn.disabled = false;
            }
        });

        async function processWav(arrayBuffer) {
            return new Promise((resolve, reject) => {
                const view = new DataView(arrayBuffer);

                if (getString(view, 0, 4) !== 'RIFF' || getString(view, 8, 4) !== 'WAVE') {
                    return reject(new Error('Not a valid WAV file.'));
                }

                let chunks = [];
                let offset = 12;
                let dataChunk = null;
                let fmtChunk = null;

                while (offset + 8 <= view.byteLength) {
                    const chunkId = getString(view, offset, 4);
                    const chunkSize = view.getUint32(offset + 4, true);
                    
                    if (offset + 8 + chunkSize > view.byteLength) {
                        console.warn(`Malformed chunk ("${chunkId}") at offset ${offset}. It claims size ${chunkSize}, but only ${view.byteLength - (offset + 8)} bytes are left. Stopping parse.`);
                        break;
                    }

                    const chunkData = arrayBuffer.slice(offset + 8, offset + 8 + chunkSize);
                    
                    const chunk = {
                        id: chunkId,
                        size: chunkSize,
                        data: chunkData
                    };
                    chunks.push(chunk);

                    if (chunkId === 'fmt ') fmtChunk = chunk;
                    else if (chunkId === 'data') dataChunk = chunk;
                    
                    offset += 8 + chunkSize + (chunkSize % 2); 
                }

                if (!fmtChunk || !dataChunk) {
                    return reject(new Error('Essential fmt or data chunk not found.'));
                }

                const fmtView = new DataView(fmtChunk.data);
                const audioFormat = fmtView.getUint16(0, true);
                const numChannels = fmtView.getUint16(2, true);
                const sampleRate = fmtView.getUint32(4, true);
                const bitsPerSample = fmtView.getUint16(14, true);
                const blockAlign = numChannels * (bitsPerSample / 8);

                if (audioFormat !== 1 && audioFormat !== 3) {
                    return reject(new Error(`Unsupported audio format: ${audioFormat}. Only PCM (1) and IEEE Float (3) are supported.`));
                }

                let silenceDurationSec = 0;
                if (unitBeatsRadio.checked) {
                    const beats = parseFloat(beatsInput.value) || 0;
                    const bpm = parseFloat(bpmInput.value) || 120;
                    if (bpm > 0) silenceDurationSec = (60.0 / bpm) * beats;
                } else {
                    const ms = parseFloat(millisecondsInput.value) || 0;
                    silenceDurationSec = ms / 1000.0;
                }
                
                if (silenceDurationSec <= 0) {
                    return reject(new Error('Silence duration must be positive.'));
                }

                const numSilenceSamples = Math.round(silenceDurationSec * sampleRate);
                const silenceBytes = numSilenceSamples * blockAlign;
                const silenceBuffer = new ArrayBuffer(silenceBytes);

                const newDataSize = silenceBytes + dataChunk.size;
                const newTotalChunksSize = chunks.reduce((sum, c) => {
                    const size = (c.id === 'data') ? newDataSize : c.size;
                    const paddedSize = size + (size % 2); 
                    return sum + 8 + paddedSize; 
                }, 0);

                const newRiffSize = 4 + newTotalChunksSize; 
                const newWavBuffer = new ArrayBuffer(newRiffSize + 8); 
                const newView = new DataView(newWavBuffer);
                let writeOffset = 0;

                writeString(newView, writeOffset, 'RIFF'); writeOffset += 4;
                newView.setUint32(writeOffset, newRiffSize, true); writeOffset += 4;
                writeString(newView, writeOffset, 'WAVE'); writeOffset += 4;

               
                for (const chunk of chunks) {
                    writeString(newView, writeOffset, chunk.id); writeOffset += 4;
                    
                    const isDataChunk = chunk.id === 'data';
                    const currentDataSize = isDataChunk ? newDataSize : chunk.size;
                    const currentData = isDataChunk ? null : chunk.data; 

                    newView.setUint32(writeOffset, currentDataSize, true); writeOffset += 4;

                    if (isDataChunk) {

                        new Uint8Array(newWavBuffer, writeOffset).set(new Uint8Array(silenceBuffer));
                        writeOffset += silenceBytes;
                        new Uint8Array(newWavBuffer, writeOffset).set(new Uint8Array(dataChunk.data));
                        writeOffset += dataChunk.size;
                    } else {
                        new Uint8Array(newWavBuffer, writeOffset).set(new Uint8Array(currentData));
                        writeOffset += currentDataSize;
                    }

                    if (currentDataSize % 2) {
                        newView.setUint8(writeOffset, 0);
                        writeOffset++;
                    }
                }
                
                resolve(new Blob([newWavBuffer], { type: 'audio/wav' }));
            });
        }

        function getString(dataView, offset, length) {
            let str = '';
            for (let i = 0; i < length; i++) {
                str += String.fromCharCode(dataView.getUint8(offset + i));
            }
            return str;
        }

        function writeString(dataView, offset, str) {
            for (let i = 0; i < str.length; i++) {
                dataView.setUint8(offset + i, str.charCodeAt(i));
            }
        }

        function updateStatus(type, message) {
            statusDiv.innerHTML = '';
            const p = document.createElement('p');
            p.textContent = message;
            if (type === 'error') {
                p.className = 'text-red-400 font-semibold';
            } else if (type === 'info') {
                p.className = 'text-blue-400';
            } else {
                p.className = 'text-gray-500';
            }
            statusDiv.appendChild(p);
        }
    </script>
</body>
</html>
